#!/usr/bin/env python3
"""
Prepare RoseTTAFold2NA input files from experimental structures.

RF2NA expects:
- Separate FASTA files for each chain
- Tags: P: (protein), D: (double-stranded DNA), S: (single-stranded DNA), R: (RNA)

Usage:
    uv run python scripts/dataset/prepare_rf2na_inputs.py --input data/experimental --output data/rf2na_inputs
    uv run python scripts/dataset/prepare_rf2na_inputs.py --structure data/experimental/8abc.cif --output data/rf2na_inputs/8abc
"""

from __future__ import annotations

import argparse
import json
import sys
from pathlib import Path

import gemmi

# Add parent to path for biostructbenchmark imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from biostructbenchmark.core.sequences import (
    classify_chains,
    get_dna_sequence,
    get_protein_sequence,
)


def get_complementary_dna(sequence: str) -> str:
    """Get complementary DNA strand (RF2NA auto-generates this for 'D:' tag)."""
    complement = {"A": "T", "T": "A", "G": "C", "C": "G"}
    return "".join(complement.get(base, base) for base in reversed(sequence))


def prepare_rf2na_input(
    structure_path: Path,
    output_dir: Path,
    generate_script: bool = True,
) -> dict:
    """
    Prepare RF2NA input files for a single structure.

    Args:
        structure_path: Path to experimental structure (CIF/PDB)
        output_dir: Directory to write FASTA files
        generate_script: Whether to generate run script

    Returns:
        Dict with input file paths and metadata
    """
    try:
        structure = gemmi.read_structure(str(structure_path))
    except Exception as e:
        return {"error": f"Failed to parse structure: {e}"}

    pdb_id = structure_path.stem.split("_")[0].upper()
    protein_chains, dna_chains = classify_chains(structure)

    if not protein_chains:
        return {"error": "No protein chains found"}
    if not dna_chains:
        return {"error": "No DNA chains found"}

    output_dir.mkdir(parents=True, exist_ok=True)

    result = {
        "pdb_id": pdb_id,
        "protein_chains": [],
        "dna_chains": [],
        "fasta_files": [],
        "run_command": None,
    }

    # Write protein FASTA files
    for chain_id in protein_chains:
        seq = get_protein_sequence(structure, chain_id)
        if not seq:
            continue

        fasta_path = output_dir / f"protein_{chain_id}.fa"
        with open(fasta_path, "w") as f:
            f.write(f">{pdb_id}_{chain_id}|protein\n")
            # Write sequence in 80-character lines
            for i in range(0, len(seq), 80):
                f.write(seq[i : i + 80] + "\n")

        result["protein_chains"].append(
            {
                "chain_id": chain_id,
                "sequence": seq,
                "length": len(seq),
                "fasta": str(fasta_path),
            }
        )
        result["fasta_files"].append(f"P:{fasta_path.name}")

    # Write DNA FASTA files
    # RF2NA expects one strand and auto-generates complement for D: tag
    dna_written = set()
    for chain_id in dna_chains:
        seq = get_dna_sequence(structure, chain_id)
        if not seq:
            continue

        # Check if this is complement of already-written strand
        complement = get_complementary_dna(seq)
        if complement in dna_written:
            continue  # Skip, RF2NA will generate this

        dna_written.add(seq)

        fasta_path = output_dir / f"dna_{chain_id}.fa"
        with open(fasta_path, "w") as f:
            f.write(f">{pdb_id}_{chain_id}|DNA\n")
            for i in range(0, len(seq), 80):
                f.write(seq[i : i + 80] + "\n")

        result["dna_chains"].append(
            {
                "chain_id": chain_id,
                "sequence": seq,
                "length": len(seq),
                "fasta": str(fasta_path),
            }
        )
        # Use D: for double-stranded DNA (auto-generates complement)
        result["fasta_files"].append(f"D:{fasta_path.name}")

    # Generate run script
    if generate_script:
        script_path = output_dir / "run_rf2na.sh"
        fasta_args = " ".join(result["fasta_files"])

        script_content = f"""#!/bin/bash
# RF2NA prediction for {pdb_id}
# Generated by prepare_rf2na_inputs.py

cd "$(dirname "$0")"

# Adjust path to RF2NA installation
RF2NA_DIR="${{RF2NA_DIR:-$HOME/code/RoseTTAFold2NA}}"

# Run prediction
"$RF2NA_DIR/run_RF2NA.sh" {pdb_id.lower()}_pred {fasta_args}

echo "Output: {pdb_id.lower()}_pred/models/model_00.pdb"
"""
        script_path.write_text(script_content)
        script_path.chmod(0o755)
        result["run_command"] = f"bash {script_path}"

    # Save metadata
    meta_path = output_dir / "metadata.json"
    meta_path.write_text(json.dumps(result, indent=2))

    return result


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Prepare RoseTTAFold2NA input files"
    )
    parser.add_argument(
        "--input",
        "-i",
        type=Path,
        help="Input directory with experimental structures",
    )
    parser.add_argument(
        "--structure",
        "-s",
        type=Path,
        help="Single structure file to process",
    )
    parser.add_argument(
        "--output",
        "-o",
        type=Path,
        required=True,
        help="Output directory for RF2NA inputs",
    )
    parser.add_argument(
        "--no-scripts",
        action="store_true",
        help="Don't generate run scripts",
    )
    args = parser.parse_args()

    if args.structure:
        # Single structure mode
        print(f"Processing {args.structure.name}...")
        result = prepare_rf2na_input(
            args.structure,
            args.output,
            generate_script=not args.no_scripts,
        )
        if "error" in result:
            print(f"Error: {result['error']}")
            return 1
        print(f"  Protein chains: {len(result['protein_chains'])}")
        print(f"  DNA chains: {len(result['dna_chains'])}")
        print(f"  Output: {args.output}")
        return 0

    elif args.input:
        # Directory mode
        structures = list(args.input.glob("*.cif")) + list(args.input.glob("*.pdb"))
        print(f"Found {len(structures)} structures in {args.input}")

        results = {"processed": [], "failed": []}

        for i, structure_path in enumerate(structures):
            pdb_id = structure_path.stem.split("_")[0].upper()
            print(f"[{i + 1}/{len(structures)}] {pdb_id}")

            output_dir = args.output / pdb_id.lower()
            result = prepare_rf2na_input(
                structure_path,
                output_dir,
                generate_script=not args.no_scripts,
            )

            if "error" in result:
                print(f"  Error: {result['error']}")
                results["failed"].append({"pdb_id": pdb_id, "error": result["error"]})
            else:
                print(f"  Proteins: {len(result['protein_chains'])}, DNA: {len(result['dna_chains'])}")
                results["processed"].append(pdb_id)

        # Summary
        print(f"\nSummary:")
        print(f"  Processed: {len(results['processed'])}")
        print(f"  Failed: {len(results['failed'])}")

        # Generate master run script
        if results["processed"] and not args.no_scripts:
            master_script = args.output / "run_all.sh"
            with open(master_script, "w") as f:
                f.write("#!/bin/bash\n")
                f.write("# Run all RF2NA predictions\n\n")
                for pdb_id in results["processed"]:
                    f.write(f"echo 'Running {pdb_id}...'\n")
                    f.write(f"(cd {pdb_id.lower()} && bash run_rf2na.sh)\n\n")
            master_script.chmod(0o755)
            print(f"\nMaster script: {master_script}")

        return 0

    else:
        print("Error: Must provide --input or --structure")
        return 1


if __name__ == "__main__":
    sys.exit(main())
